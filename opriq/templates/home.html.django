{% extends "base.html.django" %}
{% block content %}
<h1 class="display-1 p-5">
    <b>O</b><small class="text-body-secondary">nline</small>
    <b>P</b><small class="text-body-secondary">rivacy</small>
    <b>Ri</b><small class="text-body-secondary">sk</small>
    <b>Q</b><small class="text-body-secondary">uantifier</small>
</h1>

<div class="row container-fluid" style="justify-content: center">
    <div class="col-auto rounded border border-3 m-2 p-2 fs-3">
        Your score is: <b id="score">00.00</b>
        <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" id="recalculate" style="margin-bottom: 4pt;" viewBox="0 0 16 16" role="button">
            <title>Recalculate</title>
            <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41m-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9"/>
            <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5 5 0 0 0 8 3M3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9z"/>
        </svg>
    </div>
</div>

<div class="row container-fluid mt-3" style="justify-content: center">
    <div class="col-auto" style="width: fit-content">
        <div class="input-group pb-1">
            <input class="form-control" type="file" id="user-file" aria-describedby="user-file-go" aria-label="Use file as input">
            <button class="btn btn-outline-primary" type="button" id="user-file-go" onclick="use_file()">Use file as input</button>
        </div>
        <p class="m-0">Please note that no data is transferred off this device.</p>
    </div>
</div>

<h2 class="mt-5">Select the items that are &ldquo;revealed&rdquo;</h2>
<div class="container-fluid" id="items"></div>
<template id="item-template">
    <div class="form-check-inline py-2">
        <input class="btn-check" type="checkbox">
        <label class="btn btn-outline-primary"></label>
    </div>
</template>

<h2 class="mt-5">Also select any modifiers that apply</h2>
<div class="row container-fluid" id="mods" style="justify-content: center"></div>
<template id="mod-template">
    <div class="col-auto rounded border border-3 m-2 p-2" style="display: none">
        <label></label>
        <select class="form-select" onclick="calculate()">
            <option selected value="0">(empty)</option>
        </select>
    </div>
</template>

<h2 class="mt-5">From the items you selected, the following can be inferred</h2>
<div class="container-fluid" id="inferred"></div>
<template id="inf-template">
    <div class="col-auto rounded border border-3 m-2 p-2" style="display: none"></div>
</template>

<script>
    HTMLCollection.prototype.forEach = Array.prototype.forEach;

    // Spin icon on click
    const icon = document.getElementById('recalculate');
    icon.addEventListener('click', () => {
        icon.classList.add('spin');
        calculate();
    });
    icon.addEventListener('animationend', () => {
        icon.classList.remove('spin');
    });

    // Establish items
    ITEMS = {{% for item in items %}
        {{ item.id }}: {"name": "{{ item.name }}", "base": "{{ item.base_sensitivity }}"}, {% endfor %}
    };

    // Dict to allow quick lookup of check values
    item_checked = {{% for item in items %}
            {{ item.id }}: false, {% endfor %}
    };

    // Create check boxes
    let item_container = $("#items")[0];
    let item_template = $("#item-template")[0];

    for (let item in ITEMS) {
        let template_clone = item_template.content.cloneNode(true);
        let inner_div = template_clone.children[0];
        let inner_input = inner_div.children[0];
        let inner_label = inner_div.children[1];

        inner_label.setAttribute("id", `label:item:${item}`);
        inner_label.setAttribute("for", `check:item:${item}`);
        inner_label.appendChild(document.createTextNode(ITEMS[item]["name"]));

        inner_input.addEventListener("click", (_) => {
            handle_item_click(item)
        });
        inner_input.setAttribute("id", `check:item:${item}`);

        item_container.appendChild(template_clone);
    }

    // Establish mods
    MODS = { {% for item in items %}{{ item.id }}: [], {% endfor %} };
    {% for mod in mods %}
    MODS[{{ mod.item_id }}].push({"value": "{{ mod.value }}", "mult": {{ mod.multiplier }}});{% endfor %}

    // Create mod selects
    let mod_container = $("#mods")[0];
    let mod_template = $("#mod-template")[0];

    for (let i in MODS) {
        // Only create select if there are options to choose from
        if (MODS[i].length > 0) {
            let template_clone = mod_template.content.cloneNode(true);
            let inner_div = template_clone.children[0];
            let inner_label = inner_div.children[0];
            let inner_select = inner_div.children[1];

            inner_div.setAttribute("id", `div:mods:${i}`);

            inner_label.setAttribute("id", `label:mods:${i}`);
            inner_label.setAttribute("for", `select:mods:${i}`);
            inner_label.appendChild(document.createTextNode(`Modifiers for ${ITEMS[i]["name"]}`));

            inner_select.setAttribute("id", `select:mods:${i}`);
            MODS[i].forEach((j, _a, _b) => {
                let option = document.createElement("option");
                option.setAttribute("value", j["mult"]);
                option.appendChild(document.createTextNode(j["value"]));

                inner_select.appendChild(option)
            });

            mod_container.appendChild(template_clone);
        }
    }

    // Establish inferences
    INFERENCES = { {% for inf in inferences %}
        {{ inf.id }}: { "from": [{{ inf.from_items_ids | join:"," }}], "to": {{ inf.to_item.id }}, "probability": {{ inf.probability }}, "toggled": false }, {% endfor %}
    };

    // Create inference boxes
    let inf_container = $("#inferred")[0];
    let inf_template = $("#inf-template")[0];

    for (let i in INFERENCES) {
        let template_clone = inf_template.content.cloneNode(true);
        let inner_div = template_clone.children[0];

        inner_div.setAttribute("id", `div:infs:${i}`);
        inner_div.appendChild(document.createTextNode(`${ITEMS[INFERENCES[i]["to"]]["name"]} with ${INFERENCES[i]["probability"] * 100}% certainty`));

        inf_container.appendChild(template_clone);
    }

    function calculate() {
        let running_sum = 0;

        for (let i in ITEMS) {
            if (item_checked[i]) {
                // If selected, just need base * mod
                // Note: mod will be 0 if not selected (see template)
                let base = ITEMS[i]["base"];

                let mod = 0;
                if (MODS[i].length > 0) {
                    mod = parseFloat(document.getElementById(`select:mods:${i}`).value);
                }

                running_sum += base * (1 + mod);
            }
        }

        for (let i in INFERENCES) {
            // Only use if all "from" are ticked and "to" is not ticked
            if (INFERENCES[i]["from"].every((j) => item_checked[j]) && !item_checked[INFERENCES[i]["to"]]) {
                let base = ITEMS[INFERENCES[i]["to"]]["base"];
                let prob = INFERENCES[i]["probability"];

                running_sum += base * prob;
            }
        }

        let num_items = Object.keys(ITEMS).length;
        let final_score = (Math.log((Math.exp(3) - 1) * (running_sum / num_items) + 1)) / 3;
        document.getElementById("score").innerText = (final_score * 100).toFixed(2);
    }

    function handle_item_click(id) {
        // Update state
        item_checked[id] = !item_checked[id];

        // Reveal mods
        let mods_elem = document.getElementById(`div:mods:${id}`);
        if (mods_elem != null) {
            if (item_checked[id]) {
                mods_elem.style.display = "inline-block";
            } else {
                mods_elem.style.display = "none";
            }
        }

        // Reveal inferences
        // TODO: Updates on every click - could be more efficient?
        for (let i in INFERENCES) {
            let inf_elem = document.getElementById(`div:infs:${i}`);
            // Only show if all from are ticked and to is not ticked
            if (INFERENCES[i]["from"].every((j) => item_checked[j]) && !item_checked[INFERENCES[i]["to"]]) {
                inf_elem.style.display = "inline-block";
            } else {
                inf_elem.style.display = "none";
            }
        }

        // TODO: some iters run twice?
        calculate();
    }

    function handle_file_parsed_id(id) {
        let element = document.getElementById(`check:item:${id}`);
        if (element != null) {
            element.click();
            return true;
        } else {
            console.log(`No item found for id "${id}"`);
            return false;
        }
    }

    function handle_file_parsed_name(name) {
        console.log(name);
        // Ignore empty names
        if (name === "" || name === null) {
            return true;
        }

        for (let j in ITEMS) {
            if (name.trim().toLowerCase() == ITEMS[j]["name"]) {
                let element = document.getElementById(`check:item:${j}`);
                if (element != null) {
                    element.click();
                    return true;
                }
            }
        }

        console.log(`No item found for name "${name}"`);
        return false;
    }

    function get_property_insensitive(object, property) {
        property = property.toLowerCase();
        for (let key in object) {
            if (key.toLowerCase() === property) {
                return object[key];
            }
        }

        return null;
    }

    function handle_file_parsed_object(object) {
        // Look for ID
        let id_keys = ["id", "item id", "item_id", "item-id"];
        for (let i in id_keys) {
            let value = get_property_insensitive(object, id_keys[i]);
            if (value != null) {
                return handle_file_parsed_id(value);
            }
        }

        // Look for name
        let name_keys = ["name", "item name", "item_name", "item-name"];
        for (let i in name_keys) {
            let value = get_property_insensitive(object, name_keys[i]);
            if (value != null) {
                return handle_file_parsed_name(value);
            }
        }

        return false;
    }

    function csv_ids(content, sep=",") {
        return content.split(sep).every(handle_file_parsed_id);
    }

    function csv_names(content, sep=",") {
        return content.split(sep).every(handle_file_parsed_name);
    }

    function handle_json_item(item) {
        let item_type = typeof item;
        switch (item_type) {
            case "string":
                // Assume name of item
                return handle_file_parsed_name(item);
            case "bigint":
            case "number":
                // Assume ID
                return handle_file_parsed_id(item);
            case "object":
                return handle_file_parsed_object(item);
            default:
                return false;
        }
    }

    function json_file(content) {
        let obj;
        try {
            obj = JSON.parse(content);
        } catch (e) {
            console.log(e);
            return false;
        }

        // Array of items?
        if (Array.isArray(obj)) {
            for (let i in obj) {
                if (!handle_json_item(obj[i])) {
                    return false;
                }
            }

            return true;
        }

        // Necessarily a dict, as JSON only supports lists or dictionaries at top-level
        // Check keys
        let json_keys = ["items", "ids", "names", "revealed"];
        for (let i in json_keys) {
            let value = get_property_insensitive(obj, json_keys[i]);
            // Check value is list
            if (value != null && Array.isArray(value)) {
                // Value is a list, same process as array above
                for (let j in value) {
                    if (!handle_json_item(value[j])) {
                        return false;
                    }
                }

                return true;
            }
        }

        return false;
    }

    let format_map = [
        [/(\d+,)+\d+/gs, csv_ids],                             // Comma-separated IDs
        [/(\d+\|)+\d+/gs, (i) => { return csv_ids(i, "|") }],  // Pipe-separated IDs
        [/(\d+:)+\d+/gs, (i) => { return csv_ids(i, ":") }],   // Colon-separated IDs
        [/(\d+\t)+\d+/gs, (i) => { return csv_ids(i, "\t") }], // Tab-separated IDs
        [/(\d+\n)+\d+/gs, (i) => { return csv_ids(i, "\n") }], // Newline-separated IDs

        [/([\w ]+,)+[\w ]+/gs, csv_names],                             // Comma-separated names
        [/([\w ]+\|)+[\w ]+/gs, (i) => { return csv_names(i, "|") }],  // Pipe-separated names
        [/([\w ]+:)+[\w ]+/gs, (i) => { return csv_names(i, ":") }],   // Colon-separated names
        [/([\w ]+\t)+[\w ]+/gs, (i) => { return csv_names(i, "\t") }], // Tab-separated names
        [/([\w ]+\n)+[\w ]+/gs, (i) => { return csv_names(i, "\n") }], // Newline-separated names
    ];

    async function use_file() {
        let file = document.getElementById("user-file").files[0];

        if (file == null) {
            alert("No file selected");
            return;
        }

        let content = await file.text();

        for (let i in format_map) {
            if (content.match(format_map[i][0])) {
                // Matched regex - commit to this format
                console.log(`Assuming ${format_map[i][0]}`);
                let result = format_map[i][1](content);
                if (!result) {
                    alert("Failed to parse file content (assumed some sort of CSV)");
                }
                return;
            }
        }

        // json_file == false may mean it's a different format. not a failure
        if (json_file(content)) {
            return;
        }

        alert("Could not detect file format");
    }
</script>
{% endblock %}
